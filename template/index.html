<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>BST Visualization</title>
    <style>
        body { text-align: center; font-family: Arial; }
        canvas { border: 1px solid black; background: #f9f9f9; margin-top: 20px; }
        input, button { font-size: 16px; margin: 5px; }
        h1, h2, h3 { margin: 5px; }
        #traversals { font-size: 16px; margin-top: 15px; }
    </style>
</head>
<body>
    <!-- Header -->
    <h1>MIT-ADT University</h1>
    <h2>DSA Jury 1</h2>
    <h3>Binary Search Tree Visualization</h3>
    <h4>Name: Atharv Prakash Sadewad, Class: SY-7, Rn: 42, En: ADT24SOCB0957</h4>

    <!-- Input -->
    <input type="number" id="nodeInput" placeholder="Enter node value">
    <button onclick="insertNode()">Insert</button>
    <button onclick="searchNode()">Search</button>
    <button onclick="deleteNode()">Delete</button>

    <canvas id="bstCanvas" width="900" height="600"></canvas>
    <div id="traversals">
        Inorder: []<br>
        Preorder: []<br>
        Postorder: []
    </div>

    <script>
        const canvas = document.getElementById("bstCanvas");
        const ctx = canvas.getContext("2d");
        const traversalsDiv = document.getElementById("traversals");

        class Node {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.left = null;
                this.right = null;
            }
        }

        let root = null;
        const nodeRadius = 20;
        const levelGap = 80;

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        // ---------- INSERT ----------
        async function insert(value) {
            root = await _insert(root, value, canvas.width / 2, 50, canvas.width / 4);
            drawTree();
            updateTraversals();
        }

        async function _insert(node, value, x, y, offset) {
            if (!node) {
                let newNode = new Node(value, x, y);
                await drawTree(newNode);
                return newNode;
            }
            await drawTree(node);
            await sleep(400);

            if (value < node.value) node.left = await _insert(node.left, value, x - offset, y + levelGap, offset / 2);
            else if (value > node.value) node.right = await _insert(node.right, value, x + offset, y + levelGap, offset / 2);
            return node;
        }

        // ---------- SEARCH ----------
        async function search(value) {
            await _search(root, value);
        }

        async function _search(node, value) {
            if (!node) {
                alert("Value not found");
                return null;
            }
            await drawTree(node);
            await sleep(500);
            if (node.value === value) {
                alert("Value found: " + value);
                return node;
            } else if (value < node.value) return _search(node.left, value);
            else return _search(node.right, value);
        }

        function searchNode() {
            const input = document.getElementById("nodeInput");
            const value = parseInt(input.value);
            if (!isNaN(value)) search(value);
            input.value = "";
            input.focus();
        }

        // ---------- DELETE ----------
        async function deleteBST(node, value) {
            if (!node) return null;
            await drawTree(node);
            await sleep(400);
            if (value < node.value) node.left = await deleteBST(node.left, value);
            else if (value > node.value) node.right = await deleteBST(node.right, value);
            else {
                // Node to delete
                if (!node.left) return node.right;
                if (!node.right) return node.left;

                // Node with two children
                let minLargerNode = node.right;
                while (minLargerNode.left) minLargerNode = minLargerNode.left;
                node.value = minLargerNode.value;
                node.right = await deleteBST(node.right, minLargerNode.value);
            }
            return node;
        }

        async function deleteNode() {
            const input = document.getElementById("nodeInput");
            const value = parseInt(input.value);
            if (!isNaN(value)) {
                root = await deleteBST(root, value);
                drawTree();
                updateTraversals();
            }
            input.value = "";
            input.focus();
        }

        // ---------- DRAW TREE ----------
        async function drawTree(highlightNode = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            _drawNode(root, highlightNode);
        }

        function _drawNode(node, highlightNode) {
            if (!node) return;
            if (node.left) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.left.x, node.left.y);
                ctx.stroke();
                _drawNode(node.left, highlightNode);
            }
            if (node.right) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.right.x, node.right.y);
                ctx.stroke();
                _drawNode(node.right, highlightNode);
            }

            ctx.beginPath();
            ctx.fillStyle = (highlightNode && node === highlightNode) ? "yellow" : "lightblue";
            ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(node.value, node.x, node.y);
        }

        // ---------- TRAVERSALS ----------
        function updateTraversals() {
            const inorder = [];
            const preorder = [];
            const postorder = [];

            function inOrder(node) { if(!node) return; inOrder(node.left); inorder.push(node.value); inOrder(node.right);}
            function preOrder(node) { if(!node) return; preorder.push(node.value); preOrder(node.left); preOrder(node.right);}
            function postOrder(node) { if(!node) return; postOrder(node.left); postOrder(node.right); postorder.push(node.value);}

            inOrder(root); preOrder(root); postOrder(root);

            traversalsDiv.innerHTML =
                `Inorder: [${inorder.join(", ")}]<br>` +
                `Preorder: [${preorder.join(", ")}]<br>` +
                `Postorder: [${postorder.join(", ")}]`;
        }

        // ---------- INPUT HANDLING ----------
        function insertNode() {
            const input = document.getElementById("nodeInput");
            const value = parseInt(input.value);
            if (!isNaN(value)) insert(value);
            input.value = "";
            input.focus();
        }

        // Press Enter for insert
        document.getElementById("nodeInput").addEventListener("keypress", function(event){
            if(event.key === "Enter") insertNode();
        });
    </script>
</body>
</html>
